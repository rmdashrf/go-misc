package rediscookiestore

import (
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"time"

	"github.com/go-redis/redis"
	"github.com/rmdashrf/go-misc/cookiejar2"
)

type RedisCookieStore struct {
	redis        *redis.Client
	id           string
	storeKey     string
	invalidateCh chan struct{}
}

func init() {
	rand.Seed(time.Now().UnixNano())
}

func NewRedisCookieStore(redis *redis.Client, storePrefix string) *RedisCookieStore {
	id := rand.Int63()

	store := &RedisCookieStore{
		redis:        redis,
		id:           fmt.Sprintf("%d", id),
		storeKey:     storePrefix,
		invalidateCh: make(chan struct{}, 1),
	}

	go store.listenForInvalidations()

	return store
}

func (r *RedisCookieStore) listenForInvalidations() {
	invName := InvalidationName(r.storeKey)
	for {
		pubsub, err := r.redis.Subscribe(invName)
		if err != nil {
			log.Printf("Failed to subscribe to %s: %v\n", invName, err)
			time.Sleep(1 * time.Second)
			continue
		}

		for {
			msg, err := pubsub.ReceiveMessage()
			if err != nil {
				log.Printf("Failed to receive invalidation message: %v\n", err)
				continue
			}

			if msg.Payload == r.id {
				// ignore messages generated by ourself
				continue
			}

			select {
			case r.invalidateCh <- struct{}{}:
			default:
			}
		}
	}
}

func (r *RedisCookieStore) InvalidationEvents() <-chan struct{} {
	return r.invalidateCh
}

func (r *RedisCookieStore) Load() (ret cookiejar2.CookieEntries, err error) {
	storeName := StoreName(r.storeKey)
	content, err := r.redis.Get(storeName).Bytes()
	if err != nil {
		if err == redis.Nil {
			return make(cookiejar2.CookieEntries), nil
		}
		return nil, err
	}

	err = json.Unmarshal(content, &ret)
	return
}

func (r *RedisCookieStore) Save(entries cookiejar2.CookieEntries) (err error) {
	return SetCookies(r.redis, r.storeKey, entries, r.id)
}

var _ cookiejar2.EntryStorage = (*RedisCookieStore)(nil)
